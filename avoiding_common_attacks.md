# Guarding Against common attacks.

1. One of the most important ways this decentralised application guards against common attacks is through **extensive testing**. Each contract is tested to check that it performs as expected when callec correctly. **Negative tests** are also run to check the contract fails gracefully (and securely) when it is called incorrectly (or by a bad actor).
2. The code has been kept **purposefully simple** where possible. This means that the logic is straightforward and clear, making it easier to reason about and consider edge cases.
3. The majority of the methods are accessible only by C level accounts (or other contracts that I have written as part of this dapp), meaning that the **likelihood of reentrancy is low**. The two methods in payment pipe that have to be open to the public (and external contracts) by design, are extensively tested. As well as this, these methods transfer both balances and OPC tokens as the final (isolated) step. As mentioned in the design patterns document, since the majority of code implemented in the token is inherited from the OpenZeplin BasicToken.sol, it uses a **pull over push approach to withdrawals and guards against reentrancy** attacks this way.
4. Integer arithmetic overflow - this is caused when integers are too large or two low to fit inside a set memory address. In order to limit this as a vector of attack the contracts make use of the **SafeMath library**. This will **throw in the case of overflow/underflow** - which would prevent any corrupted data from being written to the blockchain.
5. **Poison data** attacks (i.e. the ability for people to enter data into your application that corrupts the state or causes other undesired consequences) have been mitigated by **limiting the amount of places where users can input data**, as well as making the implications larger for the user. The only place where a user can input into the funding application is in order to specify how many of their OPC tokens they would like to spend. This call then uses the safe math library operating under the hood of the token contract to **ensure that the value passed is safe** (and that the user actually has that amount of tokens to spend). All other methods which accept input data are limited to either the address of another contract that I control or the associated C level accounts.
6. Since there are some for-loops in the application, it was important to mitigate the possibility of **denial of service attacks**. This was primarily done by **restricting acces**s of these functions to friendly actors (C level accounts). Another method I employed was to track the indexes of any arrays that I wanted to loop over - this would mean that the **loop was always of a fixed length and an out of gas exception could not occu**r.
7. The contracts are made more secure through the extensive testing surrounding the **accessibility of functions** - these tests make sure that all functions were only callable by those with the **right permissions**.
8. Since the **time stamp** can be altered by minors, it was not appropriate to rely on this in the contracts. Instead, the transitiong between state (such as open and closing voting), is handled by separate calls to the blockchain. Although this slightly increases gas costs and the need for outside admin, it has the advantage of not requiring an outside source or the blockchain timestamp to govern when voting is accessible.
9. The threat of **malicious admins** is mitigated by the ability of **only the CEO to update and change the addresses of other C level admins**. Similarly, **only the CEO is able to unpause a contract** after it has been paused. This means that if one bad actor is discovered, any C level account can pause the contract (meaning a quick response from the community), but only the CEO is able to unpause the contract.
10. Since the core developers have publicly stated to **not use or rely on tx.origin**, the contracts instead make use of msg.sender which is not deprecated and there are no known bugs with this approach.
11. One other problem to guard against was an **out of gas exception caused the length of data input by users**. This was a concern in the submitApplication method, but because the actor here is motivated by a desire to submit the application, it is not a concern here that data would be too large as this failure would not cause any other part of the application to break. 
12. The contracts mitigate the problem of **force sending Ether** by **not utilising the balance in logic operations**. The balance is only used at the end of these operations to transfer funds to the winner.
