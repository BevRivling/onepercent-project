# Design Patterns

1. A circuit breaker has been implemented in each contract in this decentralised application. Since bugs are an unfortunate inevitability, the AccessControl.sol contract implements a **circuit breaker design pattern**. This allows certain privileged accounts the ability to pause each contract in the event of an emergency or bug discovery. 
2. The application also compiles with the best practice principle of **limiting the amount of ether at stake**. The decision to introduce a cyclical series of opening and closing voting windows means that each funding round must be concluded before another can begin. This has the affect of managing the amount at stake in the contract, since the balance is released to the winner each voting cycle.
3. Having an effective **upgrade path** is crucial to ensuring the longevity of the decentralised application. The design pattern for this is outlined in the Relay.sol. The addresses of the different applications are also able to be set dynamically, ensuring that **dependencies can be upgraded** is a new version of one contract is deployed.
4. Each contract is thoroughly **tested** and adheres to the principle of **test driven development**. This ensures that bugs are caught before deployment. 
5. The so- alled **Mortal** design pattern has also been implemented, in which each contract is able to be destroyed by calling selfdestruct(). This frees up space on the blockchain and has the added bonus of reducing gas costs for certain functions. Access to these functions is restricted to a limited set of addresses via the AccessControl contract.
6. **Access throughout the application is restricted** through the AccessControl.sol. This defines a set of controls and roles to ensure the integrity of the application. This contract is thoroughly tested, and is reused throughout the codebase (multiple separate contracts inherit from AccessControl). This **modularisation of the code** means the codebase is much simpler and easy to test, reducing the complexity and scope for bugs.
7. In general **simplicity** has been favoured where possible, to ensure that complexity does not obscure hard-to-find bugs. 
8. The application **relies on battle-tested-code** where possible. Rather than reinventing the wheel, the decentralised application makes use of **libraries or standard packages (from EthPM)**. In particular it uses the StandardToken made available by OpenZeplin.
9. The “**Pull over Push Payments**” design pattern has been implemented here, since the code relies on OpenZeplin’s BasicToken. This handles accounting separately to withdrawal methods to **guard against reentrancy attack**s.
10. The application also adheres to the “**fail loud and fail early**” design pattern by relying on **extensive modifiers**. This checks that all necessary conditions are met before any of the code runs. These implement require statements ensuring that when certain conditions aren’t met the contract call will fail. 
11. Care has also been taken when considering external contract calls. In all places but one, the external calls are to other contracts within the codebase. This means we are not deferring calls to dangerous contracts. Due to the nature of the application, one call to an unknown external contract was unavoidable. This danger is mitigated through the use of assembly code. This **untrusted method is also marked explicitly** in the method name - “callUntrustedContractWithOnePercentTax” as per the Consensys guidelines outlined here - https://consensys.github.io/smart-contract-best-practices/recommendations/. This vector of attack is further mitigated by the fact that **no state changes are made after the external contract call**, limiting the potential of vulnerabilities caused by race conditions. 
12. Then main funding contract operates as a **state machine**, and has clearly defined states for when applications are open/closed and when voting is open/closed. This means that the state transitions must be managed by C level addresses, but the code is much simpler to understand and test. This prevents state from becoming too complex within the contract itself, and opening it up to security vulnerabilities.
13. Creating a small fee to submit applications means that the contract can retain some ether to cover admin fees and dissuade people from submitting ill conceived applications.
14. The ability to dynamically set the cost in wei (by a C level account) means that the contract can stay reasonably priced as the value of Ether fluctuates.
15. Since the contract loops over applications in places, I wanted to make sure these were well tested, as any off (out of bounds) indexing would cause the contract to break. This is the most well tested part of the application - which covers multiple rounds of voting and multiple scenarios of when applications are submitted and voted on.
16. When voting closes and the contract calculates the winner, the expensive costs of a for loop are offset here by the contract calling **selfdestruct** on the applications (this has a negative gas cost). To handle vote counting and contract destruction all within one for loop meant carefully tracking the addresses of the highest voted applications (so that the votes could be counted and the address stored in the same for loop as the selfdestruct call). Although this adds some complexity to the code, it massively reduced the gas cost of the operation. I utilised **extensive testing** here to ensure the contract worked as expected and that the correct winner would be calculated each time. Here I **tested edge cases** such as when the vote is tied, or there is no winner (i.e. no applications received any votes). Testing each of these scenarios highlighted vulnerabilities before the contracts were deployed and allowed me to find and remove bugs quickly during development.
17. In order to give everybody an equal chance to vote on applications, OPC tokens are given out in return for number of payments rather than as a proportion of the size of the payment. This means that the **contract code is much simpler** and therefore less prone to bugs. This means however that there might be a temptation by users to make high frequency but low value transactions, clogging up the network, in return for OPC tokens. In order to mitigate this risk, a minimum payment amount is set in the payment pipe that users must meet in order to receive OPC tokens. C level accounts are able to update this amount once the contract is live, in order to respond to changes in frequency of requests.
